Pentru implementarea eliminarii de exceptii folosind statistici, am parcurs lista de la i = 1 la list->PairNumbers - 5. Am folosit functiile din tema pentru calcularea mediei si deviatei pe ferestre de k = 5 elemente. Pentru calculul deviatei si mediei pe fiecare segment de 5 elem, am parcurs lista de la list->head la z < i (echialentul a s1 = 0 inainte de fiecare for). Dupa am verificat daca elementul curent este in afara intervalului si am folosit un marcator care devine 1 in cazul in care e in afara lui. In final, am parcurs lista pana la capat, iar elementele unde markatorul era egal cu 1 le-am eliminat din lista.

Pentru implementarea functiei care elimina zgomot prin filtru median, am folosit o functie ajutatoare in care puneam cate 5 elemente, sortam lista, si puneam elementul din mijlocul listei intr-o lista noua. 

Pentru implementarea functiei care elimina zgomot prin filtru bazat pe media aritmetica, am folosit ideea de la functia anterioara, si anume: am pus cate 5 elemente intr-o lista ajutatoare, am calculat media aritmetica a elementelor din lista respectiva, si am adaugat elementul din mijloc intr-o lista noua.

Pentru implementarea functiei care uniformizeaza frecventa, am parcurs lista incepand cu al doilea element (deoarece primul element nu avea ->prev cu care sa verific diferenta) si la fiecare pas calculam diferenta dintre elementul curent si cel anterior. Daca diferenta dintre cele doua apartinea intervalului [100, 1000], timestamp-ul si value-ul luau valoarea mediei aritmetice dintre valoarea curenta si cea anterioara.

Pentru statistici, am ales sa refolosesc functia de sortare (astfel head-ul e minimul listei, si tail-ul e maximul listei). Am luat marginea din stanga ca fiind diferenta dintre minim si restul impartirii minimului la omega, iar in cazul in care minimul era negativ, am mai scazut inca o data omega. Marginea din dreapta este, in mod mai simplu, marginea din stanga la care adaugam omega. Am parcurs lista cat timp marginea din dreapta este mai mica sau egala decat maximul + omega. Am initializat un contor, dupa care am parcurs lista, si in cazul in care valoarea din nodul curent apartinea intervalului dintre margini, incrementam contorul. Apoi intr-un if verificam daca contorul e diferit de 0, adica daca avem valori in intre marginile respective, si, daca da, afisam marginile si nr de elemente care se afla in acel interval. Apoi cresteam marginile din stanga si din dreapta cu omega.

In main am declarat 3 functii, pentru ca in cadrul functiilor e2 si e3 am facut un fel de "cascada", se va intelege la apelare.  Am citit cate numere de perechi sunt in lista, apoi am citit perechile respective;

Acum afisarea nu este probabil cea mai corespunzatoare, pentru ca nu e la cazul general. Am incercat sa pun schimbarile din cadrul functiilor e2 si e3 inapoi in list-ul initial, dar aveam probleme la  valgrind si nu am reusit. Am incercat sa eliberez lista initiala si sa dau list = list2. Intr-un final am ales sa fac apelarea si afisarea pe cazuri particulare, cu cascada intre liste, in loc de un for care verifica pentru fiecare argv[i] in parte.
